<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>How Big Is This? Acres Visualizer</title>
  <meta name="description" content="Enter acres and see how big it is as a highlighted portion of the US or world map." />

  <style>
    :root{
      --bg:#0b1020;
      --card:#121a33;
      --text:#e8ecff;
      --muted:#aab3da;
      --line:rgba(255,255,255,.12);
      --accent:#7c5cff;
      --accent2:#00d4ff;
      --warn:#ffb020;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1100px 600px at 20% 0%, rgba(124,92,255,.22), transparent 60%),
                  radial-gradient(900px 500px at 90% 10%, rgba(0,212,255,.18), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 22px 16px 40px;
    }
    h1{font-size: clamp(22px, 3.2vw, 34px); margin: 10px 0 6px;}
    p{margin:0 0 14px; color:var(--muted); line-height:1.45}
    .card{
      background: linear-gradient(180deg, rgba(18,26,51,.95), rgba(18,26,51,.75));
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.30);
    }
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 860px){
      .grid{grid-template-columns: 1fr;}
    }
    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:end;
    }
    label{display:block; font-size:12px; color:var(--muted); margin:0 0 6px;}
    input, select{
      width: 260px;
      max-width: 100%;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(15,23,48,.95);
      color: var(--text);
      outline: none;
    }
    input:focus, select:focus{
      border-color: rgba(124,92,255,.7);
      box-shadow: 0 0 0 4px rgba(124,92,255,.18);
    }
    .btn{
      padding: 11px 14px;
      border-radius: 12px;
      border:1px solid rgba(124,92,255,.55);
      background: rgba(124,92,255,.18);
      color: var(--text);
      cursor: pointer;
      user-select:none;
    }
    .btn:hover{background: rgba(124,92,255,.26);}
    .hint{font-size:12px; color:var(--muted); margin-top:8px;}
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    .stat{
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      background: rgba(15,23,48,.55);
    }
    .stat .k{font-size:12px; color:var(--muted);}
    .stat .v{font-size:18px; margin-top:4px;}
    .warn{
      color: var(--warn);
      font-size: 12px;
      margin-top: 10px;
      min-height: 16px;
      white-space: pre-wrap;
    }

    /* SVG styling */
    .viz{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(15,23,48,.45);
      padding: 12px;
    }
    .legend{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:10px; color:var(--muted); font-size:12px;
      align-items:center;
    }
    .dot{
      width:10px;height:10px;border-radius:999px; display:inline-block; margin-right:6px;
      border:1px solid rgba(255,255,255,.25);
    }
    .dot.fill{background: rgba(0,212,255,.75);}
    .dot.base{background: rgba(232,236,255,.12);}

    /* Zoom view */
    .zoomWrap{
      margin-top: 12px;
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      background: rgba(15,23,48,.55);
      display:none;
    }
    .zoomTitle{
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .zoomBarOuter{
      width:100%;
      height:14px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(232,236,255,.06);
      overflow:hidden;
    }
    .zoomBarInner{
      height:100%;
      width:0%;
      background: rgba(0,212,255,.75);
    }
    .zoomNote{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }

    .footer{margin-top:14px; font-size:12px; color:var(--muted);}
    a{color:var(--accent2); text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Acres Visualizer (US / World)</h1>
    <p>Enter an area in acres and see it highlighted as a portion of the US or world land area. (No AI. Just math + visuals.)</p>

    <div class="grid">
      <div class="card">
        <div class="row">
          <div>
            <label for="acres">Acres</label>
            <input id="acres" type="number" min="0" step="1" value="1000000" />
          </div>

          <div>
            <label for="mode">Compare to</label>
            <select id="mode">
              <option value="us">United States (land area)</option>
              <option value="world">World (land area)</option>
            </select>
          </div>

          <button class="btn" id="exampleBtn" type="button">Try “1,000,000”</button>
        </div>

        <div class="hint">
          Tip: The main highlight is true scale. If it’s too small to see, a “Zoom View” appears below.
        </div>

        <div class="stats">
          <div class="stat">
            <div class="k">Percent of selected land area</div>
            <div class="v" id="pct">—</div>
          </div>
          <div class="stat">
            <div class="k">Equivalent square miles</div>
            <div class="v" id="sqmi">—</div>
          </div>
        </div>

        <div class="warn" id="warn"></div>

        <div class="zoomWrap" id="zoomWrap">
          <div class="zoomTitle">
            <span><b>Zoom View</b> (magnified for visibility)</span>
            <span id="zoomFactorText">×—</span>
          </div>
          <div class="zoomBarOuter" aria-label="Zoomed fraction bar">
            <div class="zoomBarInner" id="zoomBar"></div>
          </div>
          <div class="zoomNote" id="zoomNote">
            This doesn’t change the real percent — it’s just a magnified view so tiny values aren’t invisible.
          </div>
        </div>

        <div class="footer">
          Files expected: <code>assets/us.svg</code> and <code>assets/world.svg</code>.
        </div>
      </div>

      <div class="viz">
        <svg id="svg" viewBox="0 0 900 520" width="100%" role="img" aria-label="Map highlight visualization" style="height:auto; display:block;">
          <defs>
            <!-- Masks are more reliable than clipPath for SVGs that have fill:none -->
            <mask id="maskUS" maskUnits="userSpaceOnUse">
              <rect x="0" y="0" width="900" height="520" fill="black"></rect>
              <g id="maskUSGroup" fill="white"></g>
            </mask>

            <mask id="maskWorld" maskUnits="userSpaceOnUse">
              <rect x="0" y="0" width="900" height="520" fill="black"></rect>
              <g id="maskWorldGroup" fill="white"></g>
            </mask>
          </defs>

          <rect x="0" y="0" width="900" height="520" fill="rgba(232,236,255,.06)"></rect>
          <rect x="60" y="100" width="780" height="320" rx="26" fill="rgba(232,236,255,.06)"></rect>

          <g id="mapGroup">
            <g id="silhouetteGroup"
               fill="rgba(232,236,255,.12)"
               stroke="rgba(232,236,255,.35)"
               stroke-width="1.5"
               stroke-linejoin="round"
               stroke-linecap="round"></g>

            <!-- Fill grows left→right; mask punches it into the silhouette -->
            <rect id="fillRect" x="0" y="0" width="0" height="520" fill="rgba(0,212,255,.75)"></rect>
          </g>

          <text x="70" y="70" fill="rgba(232,236,255,.75)" font-size="20" font-weight="600" id="titleText">
            United States (land area)
          </text>
          <text x="70" y="95" fill="rgba(170,179,218,.95)" font-size="13">
            Highlight grows left → right based on acres entered
          </text>
        </svg>

        <div class="legend">
          <span><span class="dot base"></span>Unhighlighted</span>
          <span><span class="dot fill"></span>Highlighted</span>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ====== CONFIG ======
  const ACRES_PER_SQMI = 640;

  const TOTAL_ACRES = {
    us: 2.27e9,
    world: 36.8e9
  };

  const MAP_BOX = { x: 80, y: 115, w: 740, h: 340 };

  const MAP_FILES = {
    us: "./assets/us.svg",
    world: "./assets/world.svg"
  };

  const MIN_VISIBLE_PX = 8;
  const MAX_ZOOM = 5000;

  // ====== ELEMENTS ======
  const els = {
    acres: document.getElementById('acres'),
    mode: document.getElementById('mode'),
    pct: document.getElementById('pct'),
    sqmi: document.getElementById('sqmi'),
    warn: document.getElementById('warn'),
    exampleBtn: document.getElementById('exampleBtn'),

    silhouetteGroup: document.getElementById('silhouetteGroup'),
    clipGroup: document.getElementById('clipGroup'),
    fillRect: document.getElementById('fillRect'),
    titleText: document.getElementById('titleText'),

    clipUSGroup: document.getElementById('clipUSGroup'),
    clipWorldGroup: document.getElementById('clipWorldGroup'),

    zoomWrap: document.getElementById('zoomWrap'),
    zoomBar: document.getElementById('zoomBar'),
    zoomFactorText: document.getElementById('zoomFactorText'),
    zoomNote: document.getElementById('zoomNote'),
  };

  let currentFit = { x0: MAP_BOX.x, x1: MAP_BOX.x + MAP_BOX.w };

  // ====== HELPERS ======
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function formatNumber(n){
    if (!isFinite(n)) return "—";
    return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
  }

  function clearChildren(el){
    while (el.firstChild) el.removeChild(el.firstChild);
  }

  function pickShapeNodes(svgDoc){
    // Keep it simple & reliable: only real geometry.
    // (Ignore defs/text/etc)
    return svgDoc.querySelectorAll("path, polygon, polyline");
  }

  function cloneShapesIntoGroup(svgDoc, targetGroup){
    clearChildren(targetGroup);

    const shapes = pickShapeNodes(svgDoc);
    shapes.forEach(node => {
      const clone = document.importNode(node, true);

      // Nuke anything that can break filling/clipping
      clone.removeAttribute("class");
      clone.removeAttribute("fill");
      clone.removeAttribute("stroke");
      clone.removeAttribute("style");

      targetGroup.appendChild(clone);
    });

    if (!targetGroup.firstChild) {
      throw new Error("No shapes found in SVG (expected path/polygon/polyline).");
    }
  }

  function forceClipPaint(groupEl){
    // Clip paths need filled area. Force every shape to fill white, no stroke.
    const all = groupEl.querySelectorAll("path, polygon, polyline");
    all.forEach(el => {
      el.setAttribute("fill", "#fff");
      el.setAttribute("stroke", "none");
      el.removeAttribute("style"); // in case style="fill:none" existed in the SVG
    });
  }

  function forceSilhouettePaint(groupEl){
    const all = groupEl.querySelectorAll("path, polygon, polyline");
    all.forEach(el => {
      // allow group styling to apply cleanly
      el.removeAttribute("style");
      el.removeAttribute("fill");
      el.removeAttribute("stroke");
    });

    // Apply your base style on the group
    groupEl.setAttribute("fill", "rgba(232,236,255,.12)");
    groupEl.setAttribute("stroke", "rgba(232,236,255,.35)");
    groupEl.setAttribute("stroke-width", "1.5");
    groupEl.setAttribute("stroke-linejoin", "round");
    groupEl.setAttribute("stroke-linecap", "round");
  }

  async function fitTransformForGroupAsync(groupEl, box){
    await new Promise(requestAnimationFrame);

    const bbox = groupEl.getBBox();
    if (!bbox.width || !bbox.height) {
      // avoid NaN transforms
      return `translate(${box.x}, ${box.y}) scale(1)`;
    }

    const scale = Math.min(box.w / bbox.width, box.h / bbox.height);

    const newW = bbox.width * scale;
    const newH = bbox.height * scale;

    const tx = box.x + (box.w - newW) / 2 - bbox.x * scale;
    const ty = box.y + (box.h - newH) / 2 - bbox.y * scale;

    return `translate(${tx}, ${ty}) scale(${scale})`;
  }

  async function loadMap(mode){
    const url = MAP_FILES[mode];
    const isWorld = mode === "world";

    els.titleText.textContent = isWorld ? "World (land area)" : "United States (land area)";

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to load ${url} (HTTP ${res.status})`);

    const text = (await res.text()).trim();
    const doc = new DOMParser().parseFromString(text, "image/svg+xml");

    // IMPORTANT: SimpleMaps often has root style="...fill:none..." which can poison descendants.
    // Removing it in the parsed doc helps, but we also wipe styles on every cloned shape above.
    const root = doc.querySelector("svg");
    if (root) root.removeAttribute("style");

    // Import silhouette
    cloneShapesIntoGroup(doc, els.silhouetteGroup);

    // Import clip shapes into the active clip group
    if (isWorld) {
      cloneShapesIntoGroup(doc, els.clipWorldGroup);
      clearChildren(els.clipUSGroup);
      els.clipGroup.setAttribute("clip-path", "url(#clipWorld)");
    } else {
      cloneShapesIntoGroup(doc, els.clipUSGroup);
      clearChildren(els.clipWorldGroup);
      els.clipGroup.setAttribute("clip-path", "url(#clipUS)");
    }

    // FORCE paint rules
    forceSilhouettePaint(els.silhouetteGroup);

    const activeClipGroup = isWorld ? els.clipWorldGroup : els.clipUSGroup;
    forceClipPaint(activeClipGroup);

    // Fit + apply identical transform to clip group
    const transformStr = await fitTransformForGroupAsync(els.silhouetteGroup, MAP_BOX);
    els.silhouetteGroup.setAttribute("transform", transformStr);
    activeClipGroup.setAttribute("transform", transformStr);

    currentFit = { x0: MAP_BOX.x, x1: MAP_BOX.x + MAP_BOX.w };
  }

  function update(){
    const mode = els.mode.value;
    let acres = Number(els.acres.value);
    if (!isFinite(acres) || acres < 0) acres = 0;

    const total = TOTAL_ACRES[mode];
    const frac = total > 0 ? acres / total : 0;
    const pct = frac * 100;

    const X0 = currentFit.x0;
    const W = currentFit.x1 - currentFit.x0;

    const fillW = clamp(frac, 0, 1) * W;
    els.fillRect.setAttribute("x", X0);
    els.fillRect.setAttribute("width", fillW);

    els.pct.textContent = `${formatNumber(pct)}%`;
    els.sqmi.textContent = formatNumber(acres / ACRES_PER_SQMI);

    if (frac > 1) {
      els.warn.textContent =
        `That’s more than 100% of the selected land area — fully highlighted (over by ${formatNumber((frac - 1) * 100)}%).`;
    } else {
      els.warn.textContent = "";
    }

    if (acres > 0 && fillW > 0 && fillW < MIN_VISIBLE_PX && frac > 0) {
      els.zoomWrap.style.display = "block";

      const targetFrac = 0.25;
      let zoomFactor = targetFrac / frac;
      zoomFactor = clamp(zoomFactor, 1, MAX_ZOOM);

      const zoomedFrac = clamp(frac * zoomFactor, 0, 1);
      els.zoomBar.style.width = `${zoomedFrac * 100}%`;
      els.zoomFactorText.textContent = `×${formatNumber(zoomFactor)} zoom`;

      els.zoomNote.textContent =
        `Real scale is ${formatNumber(pct)}%. Zoom View magnifies the fraction by ×${formatNumber(zoomFactor)} so it’s visible.`;
    } else {
      els.zoomWrap.style.display = "none";
      els.zoomBar.style.width = "0%";
    }
  }

  async function init(){
    await loadMap(els.mode.value);
    update();

    els.acres.addEventListener("input", update);

    els.mode.addEventListener("change", async () => {
      await loadMap(els.mode.value);
      update();
    });

    els.exampleBtn.addEventListener("click", () => {
      els.acres.value = 1000000;
      update();
      els.acres.focus();
      els.acres.select();
    });
  }

  init().catch(err => {
    console.error(err);
    els.warn.textContent =
      `Map load error. Make sure you added /assets/us.svg and /assets/world.svg. (${err.message})`;
  });
</script>
</body>
</html>
