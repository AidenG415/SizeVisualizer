<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>How Big Is This? Acres Visualizer</title>
  <meta name="description" content="Enter acres and see how big it is as a highlighted portion of the US or world map." />

  <style>
    :root{
      --bg:#0b1020;
      --card:#121a33;
      --text:#e8ecff;
      --muted:#aab3da;
      --line:rgba(255,255,255,.12);
      --accent:#7c5cff;
      --accent2:#00d4ff;
      --warn:#ffb020;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1100px 600px at 20% 0%, rgba(124,92,255,.22), transparent 60%),
                  radial-gradient(900px 500px at 90% 10%, rgba(0,212,255,.18), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 22px 16px 40px;
    }
    h1{font-size: clamp(22px, 3.2vw, 34px); margin: 10px 0 6px;}
    p{margin:0 0 14px; color:var(--muted); line-height:1.45}
    .card{
      background: linear-gradient(180deg, rgba(18,26,51,.95), rgba(18,26,51,.75));
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.30);
    }
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 860px){
      .grid{grid-template-columns: 1fr;}
    }
    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:end;
    }
    label{display:block; font-size:12px; color:var(--muted); margin:0 0 6px;}
    input, select{
      width: 260px;
      max-width: 100%;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(15,23,48,.95);
      color: var(--text);
      outline: none;
    }
    input:focus, select:focus{
      border-color: rgba(124,92,255,.7);
      box-shadow: 0 0 0 4px rgba(124,92,255,.18);
    }
    .btn{
      padding: 11px 14px;
      border-radius: 12px;
      border:1px solid rgba(124,92,255,.55);
      background: rgba(124,92,255,.18);
      color: var(--text);
      cursor: pointer;
      user-select:none;
    }
    .btn:hover{background: rgba(124,92,255,.26);}
    .hint{font-size:12px; color:var(--muted); margin-top:8px;}
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    .stat{
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      background: rgba(15,23,48,.55);
    }
    .stat .k{font-size:12px; color:var(--muted);}
    .stat .v{font-size:18px; margin-top:4px;}
    .warn{
      color: var(--warn);
      font-size: 12px;
      margin-top: 10px;
      min-height: 16px;
      white-space: pre-wrap;
    }

    /* SVG styling */
    .viz{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(15,23,48,.45);
      padding: 12px;
    }
    .legend{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:10px; color:var(--muted); font-size:12px;
      align-items:center;
    }
    .dot{
      width:10px;height:10px;border-radius:999px; display:inline-block; margin-right:6px;
      border:1px solid rgba(255,255,255,.25);
    }
    .dot.fill{background: rgba(0,212,255,.75);}
    .dot.base{background: rgba(232,236,255,.12);}

    /* Zoom view */
    .zoomWrap{
      margin-top: 12px;
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      background: rgba(15,23,48,.55);
      display:none;
    }
    .zoomTitle{
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .zoomBarOuter{
      width:100%;
      height:14px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(232,236,255,.06);
      overflow:hidden;
    }
    .zoomBarInner{
      height:100%;
      width:0%;
      background: rgba(0,212,255,.75);
    }
    .zoomNote{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }

    .footer{margin-top:14px; font-size:12px; color:var(--muted);}
    a{color:var(--accent2); text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Acres Visualizer (US / World)</h1>
    <p>Enter an area in acres and see it highlighted as a portion of the US or world land area. (No AI. Just math + visuals.)</p>

    <div class="grid">
      <div class="card">
        <div class="row">
          <div>
            <label for="acres">Acres</label>
            <input id="acres" type="number" min="0" step="1" value="1000000" />
          </div>

          <div>
            <label for="mode">Compare to</label>
            <select id="mode">
              <option value="us">United States (land area)</option>
              <option value="world">World (land area)</option>
            </select>
          </div>

          <button class="btn" id="exampleBtn" type="button">Try “1,000,000”</button>
        </div>

        <div class="hint">
          Tip: The main highlight is true scale. If it’s too small to see, a “Zoom View” appears below.
        </div>

        <div class="stats">
          <div class="stat">
            <div class="k">Percent of selected land area</div>
            <div class="v" id="pct">—</div>
          </div>
          <div class="stat">
            <div class="k">Equivalent square miles</div>
            <div class="v" id="sqmi">—</div>
          </div>
        </div>

        <div class="warn" id="warn"></div>

        <div class="zoomWrap" id="zoomWrap">
          <div class="zoomTitle">
            <span><b>Zoom View</b> (magnified for visibility)</span>
            <span id="zoomFactorText">×—</span>
          </div>
          <div class="zoomBarOuter" aria-label="Zoomed fraction bar">
            <div class="zoomBarInner" id="zoomBar"></div>
          </div>
          <div class="zoomNote" id="zoomNote">
            This doesn’t change the real percent — it’s just a magnified view so tiny values aren’t invisible.
          </div>
        </div>

        <div class="footer">
          Files expected: <code>assets/us.svg</code> and <code>assets/world.svg</code>.
        </div>
      </div>

      <div class="viz">
        <svg id="svg" viewBox="0 0 900 520" width="100%" role="img" aria-label="Map highlight visualization" style="height:auto; display:block;">
          <defs>
            <!-- Masks are more reliable than clipPath for SVGs that have fill:none -->
            <mask id="maskUS" maskUnits="userSpaceOnUse">
              <rect x="0" y="0" width="900" height="520" fill="black"></rect>
              <g id="maskUSGroup" fill="white"></g>
            </mask>

            <mask id="maskWorld" maskUnits="userSpaceOnUse">
              <rect x="0" y="0" width="900" height="520" fill="black"></rect>
              <g id="maskWorldGroup" fill="white"></g>
            </mask>
          </defs>

          <rect x="0" y="0" width="900" height="520" fill="rgba(232,236,255,.06)"></rect>
          <rect x="60" y="100" width="780" height="320" rx="26" fill="rgba(232,236,255,.06)"></rect>

          <g id="mapGroup">
            <g id="silhouetteGroup"
               fill="rgba(232,236,255,.12)"
               stroke="rgba(232,236,255,.35)"
               stroke-width="1.5"
               stroke-linejoin="round"
               stroke-linecap="round"></g>

            <!-- Fill grows left→right; mask punches it into the silhouette -->
            <rect id="fillRect" x="0" y="0" width="0" height="520" fill="rgba(0,212,255,.75)"></rect>
          </g>

          <text x="70" y="70" fill="rgba(232,236,255,.75)" font-size="20" font-weight="600" id="titleText">
            United States (land area)
          </text>
          <text x="70" y="95" fill="rgba(170,179,218,.95)" font-size="13">
            Highlight grows left → right based on acres entered
          </text>
        </svg>

        <div class="legend">
          <span><span class="dot base"></span>Unhighlighted</span>
          <span><span class="dot fill"></span>Highlighted</span>
        </div>
      </div>
    </div>
  </div>

<script>
  // ====== CONFIG ======
  const ACRES_PER_SQMI = 640;

  // Approx land areas in acres (only for fraction math)
  const TOTAL_ACRES = {
    us: 2.27e9,
    world: 36.8e9
  };

  // Where to place the map inside the SVG (same coordinate system as viewBox 0..900 x 0..520)
  const MAP_BOX = { x: 80, y: 115, w: 740, h: 340 };

  // SVG files (must exist)
  const MAP_FILES = {
    us: "./assets/us.svg",
    world: "./assets/world.svg"
  };

  // When highlight width is below this many px, show zoom view
  const MIN_VISIBLE_PX = 8;

  // Max zoom factor for the zoom view bar
  const MAX_ZOOM = 5000;

  // Raster sampling scale for accurate area cutoff (2 is usually plenty; 3 = more precise but slower)
  const AREA_SAMPLE_SCALE = 2;

  // ====== ELEMENTS ======
  const els = {
    acres: document.getElementById('acres'),
    mode: document.getElementById('mode'),
    pct: document.getElementById('pct'),
    sqmi: document.getElementById('sqmi'),
    warn: document.getElementById('warn'),
    exampleBtn: document.getElementById('exampleBtn'),

    silhouetteGroup: document.getElementById('silhouetteGroup'),
    fillRect: document.getElementById('fillRect'),
    titleText: document.getElementById('titleText'),

    // These MUST exist in your SVG defs (if you switched to masks, keep these IDs consistent)
    maskUSGroup: document.getElementById('maskUSGroup'),
    maskWorldGroup: document.getElementById('maskWorldGroup'),

    zoomWrap: document.getElementById('zoomWrap'),
    zoomBar: document.getElementById('zoomBar'),
    zoomFactorText: document.getElementById('zoomFactorText'),
    zoomNote: document.getElementById('zoomNote'),
  };

  let currentFit = { x0: MAP_BOX.x, x1: MAP_BOX.x + MAP_BOX.w };

  // Holds the precomputed "true area" model for the current map mode
  let areaModel = null;

  // ====== HELPERS ======
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function formatNumber(n){
    if (!isFinite(n)) return "—";
    return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
  }

  function clearChildren(el){
    while (el.firstChild) el.removeChild(el.firstChild);
  }

  // Only keep real geometry
  function pickShapeNodes(svgDoc){
    return svgDoc.querySelectorAll("path, polygon, polyline");
  }

  // Clone shapes and strip paint attributes/styles so we control fill/stroke
  function cloneShapesIntoGroup(svgDoc, targetGroup){
    clearChildren(targetGroup);

    const shapes = pickShapeNodes(svgDoc);
    shapes.forEach(node => {
      const clone = document.importNode(node, true);
      clone.removeAttribute("class");
      clone.removeAttribute("fill");
      clone.removeAttribute("stroke");
      clone.removeAttribute("style");
      targetGroup.appendChild(clone);
    });

    if (!targetGroup.firstChild) {
      throw new Error("No shapes found in SVG (expected path/polygon/polyline).");
    }
  }

  // For the visible silhouette
  function styleSilhouette(groupEl){
    // ensure descendants don't override paint
    const all = groupEl.querySelectorAll("path, polygon, polyline");
    all.forEach(el => {
      el.removeAttribute("style");
      el.removeAttribute("fill");
      el.removeAttribute("stroke");
    });

    groupEl.setAttribute("fill", "rgba(232,236,255,.12)");
    groupEl.setAttribute("stroke", "rgba(232,236,255,.35)");
    groupEl.setAttribute("stroke-width", "1.5");
    groupEl.setAttribute("stroke-linejoin", "round");
    groupEl.setAttribute("stroke-linecap", "round");
  }

  // For mask groups: MUST be solid white fill, no stroke
  function styleMaskGroup(groupEl){
    const all = groupEl.querySelectorAll("path, polygon, polyline");
    all.forEach(el => {
      el.setAttribute("fill", "#fff");
      el.setAttribute("stroke", "none");
      el.removeAttribute("style"); // in case original SVG had fill:none
    });
    groupEl.setAttribute("fill", "#fff");
    groupEl.setAttribute("stroke", "none");
    groupEl.removeAttribute("style");
  }

  async function fitTransformForGroupAsync(groupEl, box){
    await new Promise(requestAnimationFrame);

    const bbox = groupEl.getBBox();
    if (!bbox.width || !bbox.height) {
      return `translate(${box.x}, ${box.y}) scale(1)`;
    }

    const scale = Math.min(box.w / bbox.width, box.h / bbox.height);
    const newW = bbox.width * scale;
    const newH = bbox.height * scale;

    const tx = box.x + (box.w - newW) / 2 - bbox.x * scale;
    const ty = box.y + (box.h - newH) / 2 - bbox.y * scale;

    return `translate(${tx}, ${ty}) scale(${scale})`;
  }

  // --- TRUE AREA ACCURACY ---
  // Build a per-column pixel area model of the (transformed) mask group inside MAP_BOX.
  // Then we can choose an xCut so that area(left of xCut)/totalArea === frac.
  async function buildAreaModelFromMaskGroup(maskGroupEl){
    // Build an SVG string containing ONLY a white silhouette on black background
    // in the SAME 900x520 coordinate system as your main SVG.
    const serializer = new XMLSerializer();
    const clonedGroup = maskGroupEl.cloneNode(true);

    // Ensure clone is paint-safe
    const nodes = clonedGroup.querySelectorAll("path, polygon, polyline");
    nodes.forEach(n => {
      n.setAttribute("fill", "#fff");
      n.setAttribute("stroke", "none");
      n.removeAttribute("style");
    });
    clonedGroup.setAttribute("fill", "#fff");
    clonedGroup.setAttribute("stroke", "none");

    const svgStr =
      `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 900 520" width="900" height="520">
         <rect x="0" y="0" width="900" height="520" fill="black"/>
         ${serializer.serializeToString(clonedGroup)}
       </svg>`;

    // Render into an offscreen canvas via <img>
    const img = new Image();
    const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgStr);

    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = () => reject(new Error("Failed to rasterize SVG for area model."));
      img.src = url;
    });

    const scale = AREA_SAMPLE_SCALE;
    const cw = 900 * scale;
    const ch = 520 * scale;

    const canvas = document.createElement("canvas");
    canvas.width = cw;
    canvas.height = ch;

    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(img, 0, 0, cw, ch);

    const x0s = Math.floor(MAP_BOX.x * scale);
    const x1s = Math.floor((MAP_BOX.x + MAP_BOX.w) * scale);
    const y0s = Math.floor(MAP_BOX.y * scale);
    const y1s = Math.floor((MAP_BOX.y + MAP_BOX.h) * scale);

    const wS = x1s - x0s;
    const col = new Uint32Array(wS);

    const imgData = ctx.getImageData(x0s, y0s, wS, y1s - y0s);
    const data = imgData.data;
    const rowW = wS;

    // Count "land pixels" per column (alpha threshold)
    // Our raster has black bg and white land, so alpha is always 255;
    // the real signal is brightness. We’ll use the red channel > ~10.
    for (let y = 0; y < (y1s - y0s); y++){
      let idx = y * rowW * 4;
      for (let x = 0; x < rowW; x++){
        const r = data[idx];       // 0..255
        // If pixel is not black, consider it land
        if (r > 10) col[x] += 1;
        idx += 4;
      }
    }

    // Prefix sums for fast lookup
    const cum = new Float64Array(wS + 1);
    let total = 0;
    for (let i = 0; i < wS; i++){
      total += col[i];
      cum[i + 1] = total;
    }

    // Binary search for xCut by target area
    function xCutForFrac(frac){
      if (!isFinite(frac) || frac <= 0) return MAP_BOX.x;
      if (frac >= 1) return MAP_BOX.x + MAP_BOX.w;

      const target = frac * total;

      // Find smallest i s.t. cum[i] >= target
      let lo = 0, hi = wS;
      while (lo < hi){
        const mid = (lo + hi) >> 1;
        if (cum[mid] >= target) hi = mid;
        else lo = mid + 1;
      }

      // Convert scaled columns back to SVG units
      return MAP_BOX.x + (lo / scale);
    }

    return { totalPixels: total, xCutForFrac };
  }

  async function loadMap(mode){
    const url = MAP_FILES[mode];
    const isWorld = mode === "world";

    els.titleText.textContent = isWorld ? "World (land area)" : "United States (land area)";

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to load ${url} (HTTP ${res.status})`);

    const text = (await res.text()).trim();
    const doc = new DOMParser().parseFromString(text, "image/svg+xml");

    // SimpleMaps often has root style="...fill:none..." — remove it.
    const root = doc.querySelector("svg");
    if (root) root.removeAttribute("style");

    // --- Import shapes into silhouette + active mask group ---
    cloneShapesIntoGroup(doc, els.silhouetteGroup);

    if (isWorld) {
      cloneShapesIntoGroup(doc, els.maskWorldGroup);
      clearChildren(els.maskUSGroup);
      // apply mask to fill rect
      els.fillRect.setAttribute("mask", "url(#maskWorld)");
    } else {
      cloneShapesIntoGroup(doc, els.maskUSGroup);
      clearChildren(els.maskWorldGroup);
      els.fillRect.setAttribute("mask", "url(#maskUS)");
    }

    // Style them
    styleSilhouette(els.silhouetteGroup);

    const activeMaskGroup = isWorld ? els.maskWorldGroup : els.maskUSGroup;
    styleMaskGroup(activeMaskGroup);

    // Fit transform based on silhouette bbox; apply SAME transform to mask group
    const transformStr = await fitTransformForGroupAsync(els.silhouetteGroup, MAP_BOX);
    els.silhouetteGroup.setAttribute("transform", transformStr);
    activeMaskGroup.setAttribute("transform", transformStr);

    currentFit = { x0: MAP_BOX.x, x1: MAP_BOX.x + MAP_BOX.w };

    // Build true-area model (this is the key)
    areaModel = await buildAreaModelFromMaskGroup(activeMaskGroup);
  }

  function update(){
    const mode = els.mode.value;
    let acres = Number(els.acres.value);
    if (!isFinite(acres) || acres < 0) acres = 0;

    const total = TOTAL_ACRES[mode];
    const frac = total > 0 ? acres / total : 0;
    const pct = frac * 100;

    const X0 = currentFit.x0;
    const W = currentFit.x1 - currentFit.x0;

    // ✅ TRUE AREA-ACCURATE cutoff
    let xCut = X0;
    if (areaModel && areaModel.totalPixels > 0) {
      xCut = areaModel.xCutForFrac(clamp(frac, 0, 1));
    } else {
      // Fallback: width-based if model isn't ready
      xCut = X0 + clamp(frac, 0, 1) * W;
    }

    const fillW = clamp(xCut - X0, 0, W);
    els.fillRect.setAttribute("x", X0);
    els.fillRect.setAttribute("width", fillW);

    // Stats
    els.pct.textContent = `${formatNumber(pct)}%`;
    els.sqmi.textContent = formatNumber(acres / ACRES_PER_SQMI);

    // Warnings
    if (frac > 1) {
      els.warn.textContent =
        `That’s more than 100% of the selected land area — fully highlighted (over by ${formatNumber((frac - 1) * 100)}%).`;
    } else {
      els.warn.textContent = "";
    }

    // Auto zoom view for tiny fills (purely visual)
    if (acres > 0 && fillW > 0 && fillW < MIN_VISIBLE_PX && frac > 0) {
      els.zoomWrap.style.display = "block";

      const targetFrac = 0.25;
      let zoomFactor = targetFrac / frac;
      zoomFactor = clamp(zoomFactor, 1, MAX_ZOOM);

      const zoomedFrac = clamp(frac * zoomFactor, 0, 1);
      els.zoomBar.style.width = `${zoomedFrac * 100}%`;
      els.zoomFactorText.textContent = `×${formatNumber(zoomFactor)} zoom`;

      els.zoomNote.textContent =
        `Real scale is ${formatNumber(pct)}%. Zoom View magnifies the fraction by ×${formatNumber(zoomFactor)} so it’s visible.`;
    } else {
      els.zoomWrap.style.display = "none";
      els.zoomBar.style.width = "0%";
    }
  }

  async function init(){
    await loadMap(els.mode.value);
    update();

    els.acres.addEventListener("input", update);

    els.mode.addEventListener("change", async () => {
      areaModel = null; // reset model while loading
      await loadMap(els.mode.value);
      update();
    });

    els.exampleBtn.addEventListener("click", () => {
      els.acres.value = 1000000;
      update();
      els.acres.focus();
      els.acres.select();
    });
  }

  init().catch(err => {
    console.error(err);
    els.warn.textContent =
      `Map load error.\nMake sure you added assets/us.svg and assets/world.svg.\n(${err.message})`;
  });
</script>
</body>
</html>
